
 /***************************************************************************/
 /*                                                                         */
 /*       Copyright (C) 2000 Daniel Sleator and David Temperley             */
 /*           See http://www.link.cs.cmu.edu/music-analysis                 */
 /*        for information about commercial use of this system              */
 /*                                                                         */
 /***************************************************************************/ 

/* This program takes as input a list of notes and beats, like that
generated by the meter program.  It generates a "stream analysis". A
stream analysis is a sorting of all the events of the piece into
horizontal streams. Well-formedness rules: all events must be
contained in exactly one stream. 2) Streams cannot cross. 3) There
can't be more than a certain number of streams at once, given by
MV. (If rule 3 conflicts with rule 1, rule 3 takes precedence; certain
notes are just ignored.) Preference rules: 1) Prefer to avoid streams
with empty spaces. 2) Prefer to avoid streams with big leaps in
pitch. 3) Prefer to avoid streams starting and stopping.

The program begins by dividing the piece into vertical columns,
according to the metrical structure.  (Unquantized notes in the
input can be handled, as explained by comments in the code. Basically
the program quantizes them.) If a note inhabits more than one
column, its integrity is preserved, in that if part of a note is in a
stream the whole thing must be in that stream.

The program works as follows. For each column, it finds all the
possible analyses of that column.  A possible analysis is one which
has streams at all the squares containing notes ("black squares"); a
possible analysis may also have streams at pitches were there were
notes recently ("grey squares").  (The number of grey squares allowed
after a black square is given by GV.)  The analyses are stored in
segment[x].analysis[y][z]; y is the number of the analysis, z is the
pitch numbers of the voices in the analysis.  The number of voices in
the analysis is stored in segment[x].analcard[y].

So for each column, we've got a bunch of possible analyses. Then we go
through and, for each pair of adjacent columns, we find all possible
transitions from each analysis in the left column to each analysis in
the right one. A transition is just some subset of the squares in each
analysis that are connected by streams. (There are a bunch of
short-cuts we take here.) For each pair of analyses there's one best
transition between them. When making the dynamic progamming table, 
we take a pair of analyses and find the best transition between them,
and add the score for that transition to the score for the pair of analyses.
Then when we want to recreate the best analysis, we have to find that
best transition again. This requires a bit more searching, but it means
that we never have to store a lot of transitions. 

The search works in the usual dynamic programming way.  We go through
and for each analysis at a segment, we find the analysis of the
previous segment that leads to the best score (using the best
transition between them).  */

#include <stdio.h>
#include <string.h>
#include "streamer.h"


void bad_param(char * line) {
  char * x;
  x = strchr(line, '\n');
  if (x != NULL) *x = '\0';
  printf("Warning: cannot interpret \"%s\" in parameters file -- skipping it.\n", line);
}

void read_parameter_file(char *filename, int file_specified) {
  char line[100];
  char part[3][100];
  int i;
  float value;
  FILE *param_stream;

  param_stream = fopen(filename, "r");
  if (param_stream==NULL) {
    if (file_specified) {
      printf("Warning: cannot open \"%s\".  Using defaults.\n", filename);
    } else {
      /*      printf("Cannot open \"%s\".  Using defaults.\n", filename);       */
    }
    return;
  }
  while(fgets(line, sizeof(line), param_stream) !=NULL) {
    for (i=0; isspace(line[i]); i++);
    if (line[i] == '%' || line[i] == '\0') continue;  /* ignore comment and blank lines */
    for (i=0; line[i] != '\0'; i++) if (line[i] == '=') line[i] = ' '; /* kill all '=' signs */
    if (sscanf(line, "%99s %99s %99s", part[0], part[1], part[2]) != 2) {
      bad_param(line);
      continue;
    }
    if (sscanf(part[1], "%f", &value) != 1) {
      bad_param(line);
      continue;
    }
    if (strcmp(part[0], "verbosity") == 0) {
      verbosity = value;
    } else if (strcmp(part[0], "maximum_voices") == 0) {
      max_voices = value;
    } else if (strcmp(part[0], "maximum_grey_squares") == 0) {
      max_grey = value;
    } else if (strcmp(part[0], "maximum_with_collisions") == 0) {
      max_collisions = value;
    } else if (strcmp(part[0], "pitch_proximity_penalty") == 0) {
      pitch_proximity_penalty = value;
    } else if (strcmp(part[0], "blank_square_penalty") == 0) {
      blank_square_penalty = value;
    } else if (strcmp(part[0], "new_voice_penalty") == 0) {
      new_voice_penalty = value;
    } else if (strcmp(part[0], "collision_penalty") == 0) {
      collision_penalty = value;
    } else if (strcmp(part[0], "top_new_voice_penalty") == 0) {
      top_new_voice_penalty = value;
    } else if (strcmp(part[0], "top_blank_square_penalty") == 0) {
      top_blank_square_penalty = value;
    }
  }      
  fclose(param_stream);
  if(verbosity >= 2) {
    printf("maximum voices = %d\n", max_voices);
    printf("maximum grey squares = %d\n", max_grey);
    printf("maximum with collisions = %d\n", max_collisions);
    printf("pitch proximity penalty = %d\n", pitch_proximity_penalty);
    printf("blank square penalty = %d\n", blank_square_penalty);
    printf("new voice penalty = %d\n", new_voice_penalty);
    printf("collision penalty = %d\n", collision_penalty);
    printf("top new voice penalty = %d\n", top_new_voice_penalty);
    printf("top blank square penalty = %d\n", top_blank_square_penalty);
  }
}



/* The following function adjusts any offtimes that aren't on beats backwards to the previous beat...this avoids small smudges 
   where a note overlaps with the following one. (If this would result in a note of zero duration, the offtime is left
   where it is) */

void adjust_notes() {
  int z, b;
  for(z=0; z<numnotes; z++) {
    for(b=0; b<numbeats; b++) {
      if(note[z].offtime>beat[b].time && note[z].offtime<beat[b+1].time) {
	if(note[z].ontime<beat[b].time) {
	  note[z].offtime=beat[b].time;
	}
      }
    }
  }
}

void create_segments() {           
  /* We create a segment at a timepoint if either a) the timepoint has a beat of segment_beat_level or higher,
     or b) there's a note onset at that timepoint. */
  int b, s, z, segbeat;
  segment[0].start=0;
  segment[0].beatlevel=beat[0].level;
  s=1;
  for (b=1; b<numbeats-1; b++) {
    segbeat=0;
    for(z=0; z<numnotes; z++) {
      if(note[z].ontime==beat[b].time) segbeat=1;
    }
    if(beat[b].level>=segment_beat_level || segbeat==1) {
      segment[s].start=beat[b].time;
      segment[s].beatlevel=beat[b].level;
      segment[s-1].end=beat[b].time;
      if(verbosity >=2 ) printf("Segment %d starts at %d and ends at %d\n", s-1, segment[s-1].start, segment[s-1].end);  
      s++;
    }
  }
  s--;                                     /* Now s = array number of final segment */
  segment[s].end=beat[numbeats-1].time;    /* We make the last segment end on the final beat of the piece (whether it's 
					      of segment_beat_level or not) */

  /* printf("Final segment ends at %d\n", segment[s].end);  */

  segtotal=s; /* array number of final segment  */

  for (s=0; s<=segtotal; s++) {
    segment[s].duration=segment[s].end-segment[s].start;
    segment[s].bsp = blank_square_penalty * segment[s].duration / 1000;
    segment[s].tbsp = top_blank_square_penalty * segment[s].duration / 1000;
    segment[s].cp = collision_penalty * segment[s].duration / 1000;
    /* printf("For seg %d, bsp = %d\n", s, bsp); */
  }
}


void fill_segments() {
  int s, i, n, x, ss, p;
  for (s=0; s<=segtotal; s++) {
    for (i=0; i<100; i++) {
      segment[s].column[i]=0;
    }
  }

  for (s=0; s<=segtotal; s++) {                
    segment[s].numnotes=0;
    for (x=0, n=0; x<numnotes; x++) {
      if(n>=max_voices) continue;                      /* Don't let the number of black squares in a segment exceed max_voices. Excessive notes
						  will just be ignored. */

      /* If a note begins between one beat and a next, assume its ontime is at the first beat. (So, here we deal
	 with unquantized note onsets) */
      if (note[x].ontime < segment[s].end && note[x].offtime > segment[s].start) {
	segment[s].inote[n]=note[x].pitch;                                             
	if (note[x].ontime >= segment[s].start || (s>0 && segment[s-1].column[note[x].pitch]<2)) {
	  segment[s].column[note[x].pitch]=3;   
	  /* Each note is marked with the number of the segment in which it begins - useful for printing out the
	     notes later */
	  note[x].segment = s;
	}
	else segment[s].column[note[x].pitch]=2;

	n++;
      }
    }
    segment[s].numnotes=n;
    segment[s].numblack=n;
    /* printf("Segment %d first pass numnotes = %d\n", s, segment[s].numnotes); */

  }

  for(p=0; p<100; p++) {
    canceled[p]=0;
  }

  for (s=0; s<=segtotal; s++) {
    n=0;

    /* Now we add grey squares after each black square - we keep adding them until the BSP for that many grey squares
       would exceed the NVP for just starting a new voice */

    for(ss=s-1; ss>=0; ss--) {
      if((segment[s].start-segment[ss].end) * blank_square_penalty / 1000 > new_voice_penalty) break;
      for(x=0; x<segment[ss].numnotes; x++) {
	p=segment[ss].inote[x];
	if(segment[s].column[p]==0 && segment[ss].column[p]>=2) {
	  segment[s].inote[segment[s].numnotes+n]=p;
	  segment[s].column[p]=1;
	  n++;
	}
      }
    }	
    /* printf("For segment %d, number of squares looked back = %d\n", s, s-ss); */
    segment[s].numnotes+=n;
    /* printf("Segment %d numnotes = %d\n", s, segment[s].numnotes);  */   /* numnotes = total number of black plus grey sqs */

    for(p=0; p<100; p++) {
      if(segment[s].column[p]>=2) {
	canceled[p+1]=1;
	canceled[p+2]=1;
	canceled[p-1]=1;
	canceled[p-2]=1;
      }
    }
    for(p=0; p<100; p++) {
      if(segment[s].column[p]>=2) canceled[p]=0;
    }

    /* This routine eliminates any grey squares on pitches where there has been a note within one or two chromatic steps more
       recently than a note of the pitch itself (but only in cases where max_grey would otherwise be exceeded) */

    if (segment[s].numnotes-segment[s].numblack > max_grey) {
      if(verbosity >= 2) printf("Doing note-canceling heuristic on segment %d (%d-note excess)\n", s, (segment[s].numnotes-segment[s].numblack)-max_grey);
      n=0;
      for(p=0; p<100; p++) {
	if (segment[s].column[p]==1 && segment[s].numnotes-(segment[s].numblack+n) > max_grey) {  
	  /* if (segment[s].column[p]==1) {  */
	  if (canceled[p]==1) {
	    segment[s].column[p]=0;
	    n++;
	  }
	}
      }
    }

    /* If the first heuristic didn't succeed in getting the number of grey squares down to max_grey, this second one throws out
       grey squares, starting from the bottom, until max_grey is reached. */

    if (segment[s].numnotes-(segment[s].numblack+n) > max_grey) {
      if(verbosity >= 2 ) printf("max_grey still exceeded by %d; doing second heuristic\n", segment[s].numnotes-(segment[s].numblack+n+max_grey));
      i=0;
      for(p=0; p<100; p++) {
	if (segment[s].column[p]==1 && segment[s].numnotes-(segment[s].numblack+n+i) > max_grey) {
	  segment[s].column[p]=0;
	  i++;
	}
      }
    }
  }
}

/* Now we create snotes, which are like inotes except they're in ascending numerical order. We also eliminate canceled notes. */

void create_snotes() {
  int s, i, j, min, prev, k, newnumnotes, p;
  for (s=0; s<=segtotal; s++) {
    newnumnotes=0;
    /* printf("Segment %d snotes:\n", s);  */
    prev=0;
    for (k=0; k<segment[s].numnotes; k++) {
      j=100;
      min=100;
      for (i=0; i<segment[s].numnotes; i++) {
	p=segment[s].inote[i];
	if(segment[s].column[p]>0 && segment[s].inote[i]<min && segment[s].inote[i]>prev) {
	  j=i;
	  min=segment[s].inote[i];
	}
      }
      if(min==100) continue;
      segment[s].snote[k]=min;
      newnumnotes++;
      /* printf("%d c%d; ", min, segment[s].column[min]); */
      prev=min;
    }
    segment[s].numnotes=newnumnotes;
    /* printf("\n"); */
    /* printf("Newnumotes = %d\n", newnumnotes); */
  }
}

void print_segments() {
  int s, i;
  for(s=0; s<=segtotal; s++) {
    printf("Segment %d contains black or grey squares at ", s); 
    for(i=0; i<segment[s].numnotes; i++) {
      printf("%d ", segment[s].snote[i]);  
    }
    printf("\n"); 
  }
}
      

/* We're generating a particular column analysis. We're going through a column which has certain black or grey squares,
generating an analysis for each subset of these squares. The squares are numbered consecutively, 1 through whatever.
numv is the number of voices in the analysis. v is the voice we're on this time through the function. m is the number
of the square we're on. (Going into the function for the first time, v and m are both set to -1. Then v is set to 0;
m is still -1. It's not until the second pass through the function, when v is set to 1, that a voice is actually assigned to
a square.) */

void generate_column_analyses(int m, int numv, int v) {
  int p, n, i, pok, aok, pp;
  v++;
  if(v<numv) {

    if(numv<=max_collisions) {
      for (p=m; p<segment[seg].numnotes; p++) {                /* Allows collisions */
	prov_analysis[v]=segment[seg].snote[m]; 
	generate_column_analyses(p, numv, v);
      }
    }
    else {
      for (p=m+1; p<segment[seg].numnotes; p++) {              /* Disallows collisions */
	if(m>-1) prov_analysis[v]=segment[seg].snote[m]; 
	generate_column_analyses(p, numv, v);
      }
    }
  }
  else {
    prov_analysis[v]=segment[seg].snote[m];

    aok=1;                                                  
    for (n=0; n<segment[seg].numnotes; n++) {
      pok=0;
      pp=segment[seg].snote[n];
      if (segment[seg].column[pp]>=2) {                     /* Now we check the analysis to make sure that all black squares
							       are covered */
	for(i=1; i<=numv; i++) {
	  if (prov_analysis[i]==segment[seg].snote[n]) pok=1;
	}	
	if(pok==0)aok=0;
      }
    }  
    for(i=1; i<=numv; i++) {
      if (i>2 && prov_analysis[i]==prov_analysis[i-1] && prov_analysis[i-1]==prov_analysis[i-2]) aok=0; 
      /* ^ This line can be used to ensure that there are never more than two voices on a square */
      
      if (i>1 && prov_analysis[i]==prov_analysis[i-1] && segment[seg].column[prov_analysis[i]]<2) aok=0;
      /* This line can be used to prevent collisions on grey squares */
    }

    if (aok==1) {
      segment[seg].analcont[a]=0;
      segment[seg].analblack[a]=0;
      for(i=1; i<=numv; i++) {
	segment[seg].analysis[a][i-1]=prov_analysis[i];
	if (segment[seg].column[prov_analysis[i]] < 3) segment[seg].analcont[a]++;   	/* records the number of squares in the
											analysis of column value 1 or 2; these
											squares must be continuations, must be
											covered by the transition. If there's
											a collision on such a square it will be
											counted twice; both voices must be
											continuations. */

	if (segment[seg].column[prov_analysis[i]] > 1) segment[seg].analblack[a]++;   /* records the number of black squares
											 in the analysis; again, collisions are
											 counted twice. */	
      }

      /* Use this routine for printing out all the analyses at a given segment */
      /*
      if(seg==1) {
	printf("Analysis %d:", a);    
	for(i=1; i<=numv; i++) {
	  printf("%d ", prov_analysis[i]);    
	  if(i==numv) printf("\n");   
	}
      } */

      segment[seg].analcard[a]=numv;
      segment[seg].analtop[a]=segment[seg].analysis[a][numv-1];
      /* printf("Number of voices in analysis = %d\n", numv);  */
      segment[seg].analscore[a] = segment[seg].bsp * (segment[seg].analcard[a]-segment[seg].analblack[a]); 
      
      if(segment[seg].column[segment[seg].analtop[a]]==1) segment[seg].analscore[a] += segment[seg].tbsp;  
      /* This line adds an extra penalty if the top voice is blank */
      
      /* printf("Blank square penalty for analysis = %d\n", segment[seg].analscore[a]);  */

      for(i=1; i<segment[seg].analcard[a]; i++) {
	/*In earlier versions this line read i=2, i<=segment[seg].analcard[a]. With this bug, no collision penalty was
	 imposed for collisions between the top two voices. */
	if(segment[seg].analysis[a][i]==segment[seg].analysis[a][i-1]) {
	  segment[seg].analscore[a] += segment[seg].cp;
	}
      }
      a++;
    }
  }
  v--;
}

void column_analyses() {
  int numv, v, n;
  for(seg=0; seg<=segtotal; seg++) {
    a=0;
    v=-1;
    for(numv=0; numv<=max_voices; numv++) {
      if (numv<=max_collisions) n=0;                         /* If the number of voices in the analysis is max_collisions or less, allow collisions */
      else n=-1;
      generate_column_analyses(n, numv, v);     /* n should be -1 to disallow collisions, 0 to allow them */
    }
    if(verbosity >= 2) printf("Number of analyses for segment %d = %d\n", seg, a);  
    segment[seg].numanal=a;
  }
}


void generate_transition_sides(int i, int m, int numv, int v, int side) {
  int p, vv, c, transgrey;
  v++;
  if(v<numv) {
    for (p=m+1; p<segment[seg].analcard[i]; p++) {
      if(m>-1) 	prov_trans[v]=segment[seg].analysis[i][m];
      generate_transition_sides(i, p, numv, v, side);
    }
  }
  else {
    prov_trans[v]=segment[seg].analysis[i][m];
    /*  printf("transition %d:\n", t);  */

    if(side==0) {
      transgrey=0;
      for(vv=1; vv<=numv; vv++) {
	if(segment[seg].column[prov_trans[vv]]==1) transgrey++;
      }	   
      if(transgrey==segment[seg].analcard[i]-segment[seg].analblack[i]) {
                                                                                 /* Only write the left transition if it covers
										  all grey squares in the analysis. */
	for(vv=1; vv<=numv; vv++) {
	  ltransition[i][t][vv-1]=prov_trans[vv];       
	}
	ltranscard[i][t]=numv;
	t++;
      }
    }

    c=0;
    if(side==1) {
      for(vv=1; vv<=numv; vv++) {                            /* Only write the right transition if all the "must-be-continuation"
							     squares are covered by it. */		    		     
	if(segment[seg].column[prov_trans[vv]]<3) c++;
      }
      if(c==segment[seg].analcont[i]) {
	for(vv=1; vv<=numv; vv++) {
	  rtransition[i][t][vv-1]=prov_trans[vv];
	}
	rtranscard[i][t]=numv;
	t++;
      }
    }
  }
}

void find_transitions(int i, int side) {
  int numv, v, maxv;
  v=-1;
  /* printf("generating transitions...\n"); */
  
  maxv=segment[seg].analcard[i];
  /* printf("Left transitions for segment %d, analysis %d:\n", seg, a); */
  t=0;
  for(numv=0; numv<=maxv; numv++) {
    generate_transition_sides(i, -1, numv, v, side);
  }
  if(verbosity >= 2) printf("%d ", t); 
  if(side==0)ltnum[i]=t;
  if(side==1)rtnum[i]=t;
}


void evaluate_transitions(int i, int j) {
  int lt, rt, la, ra, v, diff, score, nvp, best_score, blt, brt, good, no_good, vv, p;
  no_good=0;
  for(v=0; v<segment[seg].analcard[j]; v++) {            /* If any of the voices in the right analysis has column value
								   <3, then there must be a voice in the left analysis at
								   the same pitch in order for there to be a valid transition */
    p=segment[seg].analysis[j][v];
    if(segment[seg].column[p]<3) {
      good=0;
      for(vv=0; vv<segment[seg-1].analcard[i]; vv++) {
	if(segment[seg-1].analysis[i][vv]==p) good=1;
      }
      if(good==0) no_good=1;
    }
  }
  if (no_good==1) {
    best_transition_score=1000;
  }
  else {
  
  /* If the above test is passed: look at each pair of transitions from that pair of analyses. If one of the voices
     in the right transition has column value < 3, then the same voice must be at that pitch
     in the left transition. */
  
    best_score=1000;          
    for(lt=0; lt<ltnum[i]; lt++) {	  
      for(rt=0; rt<rtnum[j]; rt++) {
	no_good=0;
	if(ltranscard[i][lt]!=rtranscard[j][rt]) continue;
	for(v=0; v<ltranscard[i][lt]; v++) {
	  if(segment[seg].column[rtransition[j][rt][v]]<3 && ltransition[i][lt][v]!=rtransition[j][rt][v]) no_good=1;
	} 
	if(no_good==1) continue;
	/* printf("Possible transition at segment %d: a %d, t %d, to a %d, t %d. ", seg, la, lt, ra, rt); */
	score=0;
	for(v=0; v<ltranscard[i][lt]; v++) {
	  diff=absdiff(ltransition[i][lt][v], rtransition[j][rt][v]);
	  /* printf("pitches %d, %d: diff=%d; ", ltransition[la][lt][v], rtransition[ra][rt][v], diff); */
	  score += pitch_proximity_penalty * diff;
	}
	nvp = new_voice_penalty * (segment[seg].analcard[j] - rtranscard[j][rt]);
	if (ltransition[i][lt][ltranscard[i][lt]-1] != segment[seg-1].analtop[i]) nvp += top_new_voice_penalty;
	if (rtransition[j][rt][rtranscard[j][rt]-1] != segment[seg].analtop[j]) nvp += top_new_voice_penalty;
	
	/* These two lines penalize cases where the top voice at left ends, or a new top voice begins at right.
	   (Note that they also penalize cases where the top voice at left goes into the middle at right; when this
	   happens, there must be a new voice starting on top at right.) The following two lines do the same
	   thing for the bass. */
	
	/* if (ltransition[la][lt][0] != segment[seg].analysis[la][0]) nvp+=10;
	   if (rtransition[ra][rt][0] != segment[seg+1].analysis[ra][0]) nvp+=10; */
	
	/* printf("%d, %d: ", segment[seg+1].analcard[ra], rtranscard[ra][rt]); */
	score+=nvp;
	/* printf("Score: %d\n", score); */
	if (score<best_score) {
	  best_score=score;
	  blt=lt;
	  brt=rt;
	}	  
      }
    }
    best_transition_score=best_score;
    for(v=0; v<ltranscard[i][blt]; v++) {
      best_rtransition[v]=rtransition[j][brt][v];
      best_ltransition[v]=ltransition[i][blt][v];
      best_transcard=ltranscard[i][blt];
    }
    /* printf("Best transition at segment %d, la=%d, ra=%d, with score %d: ", seg, i, j, best_transition_score);   
    for(v=0; v<best_transcard; v++) {
      printf("%d->%d ", best_ltransition[v], best_rtransition[v]);
    }
    printf("\n");  */
  }
}
  
int absdiff(int x, int y) {
  if (x>=y) return (x-y);
  else return (y-x);
}

void analyze_piece() {

  /* The possible column analyses for all segments have already been generated. Now we go through
     and build the dynamic programming table. In the process, we generate transitions and find the
     best transition for each analysis pair. */

  /* First we do a special version of the search for segment 1 only */

  int bestscore, i, j, current_score;
  if(verbosity >= 2) printf("\nSegment 1 L:");
  seg=0;
  for(i=0; i<segment[0].numanal; i++) {
    find_transitions(i, 0);
  }
  if(verbosity >= 2) printf("\nSegment 1 R:");   
  seg=1;
  for(j=0; j<segment[1].numanal; j++) {
    find_transitions(j, 1);
  }

  for(j=0; j<segment[1].numanal; j++) {
    bestscore=1000;
    for(i=0; i<segment[0].numanal; i++) {
      evaluate_transitions(i,j);
      current_score=segment[0].analscore[i] + segment[1].analscore[j] + best_transition_score + 20*segment[0].analcard[i];
      if(current_score < bestscore) {      
	bestscore = current_score;
	best[1][j]=i;
	/* printf("The best i for j=%d is %d with score=%d\n", j, best[1][j], bestscore); */
      }
    }
    global_analysis[1][j]=bestscore;
  }

  /* Now we do the search for all subsequent segments */

  for(seg=2; seg<=segtotal; seg++) {
    if(verbosity >= 2) printf("\nSegment %d L:", seg); 
    seg--;
    for(i=0; i<segment[seg].numanal; i++) {
      find_transitions(i, 0);
    }
    seg++;
    if(verbosity >=2) printf("\nSegment %d R:", seg); 
    for(j=0; j<segment[seg].numanal; j++) {
      find_transitions(j, 1);
    }
    for(j=0; j<segment[seg].numanal; j++) {
      bestscore=1000000;
      for(i=0; i<segment[seg-1].numanal; i++) {
	evaluate_transitions(i,j);
	if(global_analysis[seg-1][i] + segment[seg].analscore[j] + best_transition_score < bestscore) {      
	  bestscore = global_analysis[seg-1][i] + segment[seg].analscore[j] + best_transition_score;
	  best[seg][j]=i;
	}
     }
      global_analysis[seg][j]=bestscore;
    }
  }
  if(verbosity >=2) printf("\n");

  /* If there are no legal analyses at a segment (numanal = 0), then global_analysis[seg][j] will not be set to
     anything (above) for any j. So it will probably be 0, so final[seg] below will probably be set to 0. 
     Segment[seg].analysis[final[seg]] will be unset, and seg[seg].analcard[final[seg]] will be unset,
     probably 0, so nothing will be printed out. In display_analysis, the colum numbers will be 0, so no
     voice numbers will be printed. */

  /* Now we find the global analysis in the final segment with the best score; we trace that back,
   choosing the best analysis ("final[seg]") for each segment. (We have also have to generate and
   evaluate transitions again, but only the ones for the chosen analyses of each segment). */

  bestscore=1000000;
  for(j=0; j<segment[segtotal].numanal; j++) {
    if(global_analysis[segtotal][j]<bestscore) {
      bestscore=global_analysis[segtotal][j];
      final[segtotal]=j;
    }
  }
  for(seg=segtotal-1; seg>=0; seg--) {
    final[seg]=best[seg+1][final[seg+1]];
  }

  for(seg=0; seg<=segtotal; seg++) {

    if(verbosity >= 2) {
      printf("Segment %d: ", seg);
      if(segment[seg].numanal==0) {
	printf("No legal analyses found at this segment. ");
	continue;
      }
      printf(" Analysis %d: ", final[seg]);
      for(i=0; i<segment[seg].analcard[final[seg]]; i++) {
	printf("%d ", segment[seg].analysis[final[seg]][i]);
      }
      printf("; Local score = %d; ", segment[seg].analscore[final[seg]]);
    }

    if(seg<segtotal) {
      find_transitions(final[seg], 0);
      seg++;
      find_transitions(final[seg], 1);
      evaluate_transitions(final[seg-1], final[seg]);
      if(verbosity >= 2) printf("Transition: ");
      for(i=0; i<best_transcard; i++) {
	final_ltransition[seg][i]=best_ltransition[i];
	final_rtransition[seg][i]=best_rtransition[i];
	if(verbosity >= 2) {
	  printf("%d -> ", final_ltransition[seg][i]);
	  printf("%d; ", final_rtransition[seg][i]);
	}
      }
      final_transcard[seg]=best_transcard;
      seg--;

    }
    if(verbosity >=2 ) {
      printf("Transition score: %d; ", best_transition_score);
      printf("Global score: %d", global_analysis[seg][final[seg]]);
      printf("\n");
    }
  }
}

void assign_voice_numbers() {
  int v=1, i, j, t, tt, set;
  for(i=0; i<segment[0].analcard[final[0]]; i++) {
    segment[0].voice_number[i]=v;
    v++;
  }
  for(seg=1; seg<=segtotal; seg++) {
    /* printf("Segment %d: ", seg); */
    t=0;
    j=0;
    for(i=0; i<segment[seg].analcard[final[seg]]; i++) {    
      set=0;
      if (final_rtransition[seg][t] == segment[seg].analysis[final[seg]][i]) {	
	while(1) {
	  if (final_ltransition[seg][t] == segment[seg-1].analysis[final[seg-1]][j]) {
	    segment[seg].voice_number[i] = segment[seg-1].voice_number[j];
	    set=1;
	    j++;
	    break;  
	  }
	  j++;
	}
	t++;
      }
      if (set==0) {
	segment[seg].voice_number[i]=v;
	v++;
	/* printf("%d ", segment[seg].voice_number[i]); */
      }
    }
    /* printf("\n"); */

    /* To force voice numbers to a segment, do so here */
    /*    if(seg==690) {
      segment[seg].voice_number[0]=32;
    } */
  }
}

void display_analysis() {
  int i, j, k, prev, twodigit, v, z;

  if(verbosity==0) {
    for(z=0; z<numnotes; z++) {
      seg = note[z].segment;
      for(i=0; i<segment[seg].analcard[final[seg]]; i++) {
	if(segment[seg].analysis[final[seg]][i] == note[z].pitch) {
	  note[z].voice_number = segment[seg].voice_number[i];
	  printf("Note %d %d %d %d\n", note[z].ontime, note[z].offtime, note[z].pitch, note[z].voice_number);
	}
      }
    }
  }

  else {
    printf("                         C1          C2          C3          C4          C5          C6          C7\n");
    for(seg=0; seg<=segtotal; seg++) {
      printf("Seg %4d (%d): ", seg, segment[seg].beatlevel);
      prev=0;
      for(i=0; i<segment[seg].analcard[final[seg]]; i++) {
	if(i==0) k=12;
	else k=segment[seg].analysis[final[seg]][i-1];
	if(prev>=10) twodigit=1;
	else twodigit=0;
	for(j=k+1+twodigit; j<segment[seg].analysis[final[seg]][i]; j++) {
	  if(j%12==0) printf(".");
	  else printf(" ");
	}
	if(i==0 || segment[seg].analysis[final[seg]][i]!=segment[seg].analysis[final[seg]][i-1]) {
	  if(segment[seg].column[segment[seg].analysis[final[seg]][i]]>=2) {
	    v=segment[seg].voice_number[i];
	    if(v>=100) v-=100;
	    if(segment[seg].analysis[final[seg]][i]==segment[seg].analysis[final[seg]][i+1]) {
	      printf("X");
	      prev=1;           /* Any one digit number would do */
	    }
	    else {
	      printf("%d", v);
	      prev=segment[seg].voice_number[i];
	    }
	  }
	  else {
	    printf("|");
	    prev=1;
	  }
	}
      }
      k=segment[seg].analysis[final[seg]][segment[seg].analcard[final[seg]]-1];
      if(prev>=10) twodigit=1;
      else twodigit=0;
      for(j=k+1+twodigit; j<100; j++) {
	if(j%12==0) printf(".");
	else printf(" ");      
      }
      printf("\n");
    }
  }
}    


int main(int argc, char * argv[]) {

    char *parameter_file, *input_file = NULL;
    int param_file_specified = 0;

    int j, i;
    int z=0, b=0, s=0;
    
    parameter_file = "parameters";
    
    for (j=1; j<argc; j++) {
      if (strcmp(argv[j], "-p") == 0) {
	parameter_file = argv[j+1];
	param_file_specified = 1;
	j++;
      } else if (input_file == NULL) {
	/* assume it's a file */
	input_file = argv[j];
      }
    }
    
    read_parameter_file (parameter_file, param_file_specified);
    
    if (input_file != NULL) {
      in_file = fopen(input_file, "r");
      if (in_file == NULL) {
	printf("I can't open that file\n");
	exit(1);
      }
    } else {
      in_file = stdin;
    }
    
    final_timepoint=0;
    while (fgets(line, sizeof(line), in_file) !=NULL) {            /* Read in Notes and Beats */
      for (i=0; isspace(line[i]); i++);
      if(line[i] == '\0') continue;
      (void) sscanf (line, "%s", noteword);
      if (strcmp (noteword, "Note") == 0) { 
	(void) sscanf (line, "%s %d %d %d", noteword, &note[z].ontime, &note[z].offtime, &note[z].pitch);
	/* printf("Note at %d\n", note[z].ontime); */
	note[z].duration = note[z].offtime - note[z].ontime;

	total_duration = total_duration + note[z].duration;

	if (z>0) {                                          /* This routine finds the last timepoint in the piece */
	  if (note[z].offtime>note[z-1].offtime) {
	    final_timepoint=note[z].offtime;
	  }
	}

	++z;

      }

      if (strcmp (noteword, "Beat") == 0) {   /* second part is meant to ignore blank lines... */
	(void) sscanf (line, "%s %d %d", noteword, &beat[b].time, &beat[b].level);
	b++;
      }
    }
    /* printf("the number of events is %d\n", z);           */
    /*	  printf("total duration is %d\n", total_duration);    */

    numnotes = z;
    numbeats = b;

    seglength = (beat[1].time-beat[0].time)/1000.0; /* define segment length as the length of the first segment (in secs) */
    /* printf("seglength = %3.3f\n", seglength); */

    adjust_notes();
    create_segments(); 
    fill_segments();
    create_snotes();
    if(verbosity >= 2) print_segments();
    column_analyses();
    analyze_piece(); 
    assign_voice_numbers();
    display_analysis(); 
    return 0;
}
